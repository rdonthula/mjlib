/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "mjlib/base/inplace_function.h"

#include <memory>
#include <string>
#include <type_traits>
#include <vector>

#include <boost/test/auto_unit_test.hpp>

using namespace mjlib;

namespace {

static int copied, moved, called_with;
static int expected;

struct Functor {
  Functor() {}
  Functor(const Functor&) { copied += 1; }
  Functor(Functor&&) noexcept { moved += 1; }
  void operator()(int i) { assert(i == expected); called_with = i; }
};

struct ConstFunctor {
  ConstFunctor() {}
  ConstFunctor(const ConstFunctor&) { copied += 1; }
  ConstFunctor(ConstFunctor&&) noexcept { moved += 1; }
  void operator()(int i) const { assert(i == expected); called_with = i; }
};

} // anonymous namespace

static std::string gLastS;
static int gLastI = 0;
static double gNextReturn = 0.0;

static double GlobalFunction(const std::string& s, int i) {
  gLastS = s;
  gLastI = i;
  return gNextReturn;
}

BOOST_AUTO_TEST_CASE(FunctionPointer) {
  // Even compatible function pointers require an appropriate amount of "storage".
  using CompatibleFunctionType = std::remove_reference_t<decltype(GlobalFunction)>;
  base::inplace_function<CompatibleFunctionType, sizeof(CompatibleFunctionType*)> fun(&GlobalFunction);

  BOOST_TEST(true == bool(fun));

  gNextReturn = 7.77;

  double r = fun("hello", 42);

  BOOST_TEST(gNextReturn == r);
  BOOST_TEST("hello" == gLastS);
  BOOST_TEST(42 == gLastI);
}

BOOST_AUTO_TEST_CASE(Lambda) {
  base::inplace_function<double(int), 8> fun;
  std::string closure("some closure");
  fun = [&closure](int x) { return GlobalFunction(closure, x); };

  gNextReturn = 7.77;

  double r = fun(42);

  BOOST_TEST(gNextReturn == r);
  BOOST_TEST(closure == gLastS);
  BOOST_TEST(42 == gLastI);
}

BOOST_AUTO_TEST_CASE(Bind) {
  base::inplace_function<double(int), 64> fun;
  std::string closure("some closure");
  fun = std::bind(GlobalFunction, closure, std::placeholders::_1);

  gNextReturn = 7.77;

  double r = fun(42);

  BOOST_TEST(gNextReturn == r);
  BOOST_TEST(closure == gLastS);
  BOOST_TEST(42 == gLastI);
}

namespace {
struct AnotherFunctor
{
    int mTotal = 0;
    static int mDestructorCalls;
    static int mConstructorCalls;
    int operator()(int x) { mTotal += x; return mTotal; }

    AnotherFunctor() { mConstructorCalls++; }
    AnotherFunctor(AnotherFunctor&&) noexcept { mConstructorCalls++; }
    AnotherFunctor(const AnotherFunctor&) { mConstructorCalls++; }
    ~AnotherFunctor() { mDestructorCalls++; }
};

int AnotherFunctor::mDestructorCalls = 0;
int AnotherFunctor::mConstructorCalls = 0;
}

BOOST_AUTO_TEST_CASE(FunctorDestruction) {
  AnotherFunctor::mDestructorCalls = 0;
  AnotherFunctor::mConstructorCalls = 0;
  {
    AnotherFunctor ftor;
    base::inplace_function<int(int), 4> fun(ftor);

    int r1 = fun(1);
    int r2 = fun(7);

    BOOST_TEST(1 == r1);
    BOOST_TEST(8 == r2);
  }
  BOOST_TEST(AnotherFunctor::mDestructorCalls == AnotherFunctor::mConstructorCalls);

  AnotherFunctor::mDestructorCalls = 0;
  AnotherFunctor::mConstructorCalls = 0;
  {
    AnotherFunctor ftor;
    base::inplace_function<int(int), 4> fun(ftor);
    base::inplace_function<int(int), 4> fun2(fun);  // copy-ctor
    base::inplace_function<int(int), 4> fun3(std::move(fun));  // move-ctor
    fun3 = fun2;  // copy-asgn
    fun3 = std::move(fun2);  // move-asgn
  }
  BOOST_TEST(AnotherFunctor::mDestructorCalls == AnotherFunctor::mConstructorCalls);
}

BOOST_AUTO_TEST_CASE(Swapping) {
  AnotherFunctor::mDestructorCalls = 0;
  AnotherFunctor::mConstructorCalls = 0;
  {
    AnotherFunctor ftor;
    auto lambda = [](int x){ return x + 10; };
    base::inplace_function<int(int), 4> fun(ftor);
    base::inplace_function<int(int), 4> fun2(lambda);

    fun.swap(fun2);  // swap...
    fun2.swap(fun);  // ...and swap back

    int r1 = fun(1);
    int r2 = fun(7);
    BOOST_TEST(1 == r1);
    BOOST_TEST(8 == r2);

    int r3 = fun2(1);
    int r4 = fun2(7);
    BOOST_TEST(11 == r3);
    BOOST_TEST(17 == r4);
  }

  BOOST_TEST(AnotherFunctor::mDestructorCalls == AnotherFunctor::mConstructorCalls);
}

BOOST_AUTO_TEST_CASE(Copying) {
  auto sptr = std::make_shared<int>(42);
  BOOST_TEST(1 == sptr.use_count());

  base::inplace_function<int(), 16> fun1 = [sptr]() { return *sptr; };
  base::inplace_function<int(), 16> fun2;

  BOOST_TEST(2 == sptr.use_count());
  BOOST_TEST(true == bool(fun1));
  BOOST_TEST(false == bool(fun2));

  fun2 = fun1;
  BOOST_TEST(3 == sptr.use_count());
  BOOST_TEST(true == bool(fun1));
  BOOST_TEST(true == bool(fun2));

  // this should call destructor on existing functor
  fun1 = nullptr;
  BOOST_TEST(2 == sptr.use_count());
  BOOST_TEST(false == bool(fun1));
  BOOST_TEST(true == bool(fun2));
}

BOOST_AUTO_TEST_CASE(SimilarTypeCopy) {
  auto sptr = std::make_shared<int>(42);
  BOOST_TEST(1 == sptr.use_count());

  base::inplace_function<int(), 16> fun1 = [sptr]() { return *sptr; };
  base::inplace_function<int(), 17> fun2(fun1); // fun1 is bigger than 17, but we should be smart about it
  base::inplace_function<int(), 18> fun3;

  BOOST_TEST(3 == sptr.use_count());
  BOOST_TEST(false == bool(fun3));
  fun3 = fun2;
  BOOST_TEST(4 == sptr.use_count());
  BOOST_TEST(true == bool(fun2));
  BOOST_TEST(true == bool(fun3));

  fun1 = nullptr;
  fun2 = nullptr;
  BOOST_TEST(2 == sptr.use_count());
  fun3 = nullptr;
  BOOST_TEST(1 == sptr.use_count());

  base::inplace_function<int(), 17> fun4;
  fun4 = fun1; // fun1 is bigger than 17, but we should be smart about it
}

BOOST_AUTO_TEST_CASE(AssignmentDifferentFunctor) {
  int calls = 0;
  base::inplace_function<int(int,int), 16> add = [&calls] (int a, int b) { ++calls; return a+b; };
  base::inplace_function<int(int,int), 16> mul = [&calls] (int a, int b) { ++calls; return a*b; };

  int r1 = add(3, 5);
  BOOST_TEST(8 == r1);

  int r2 = mul(2, 5);
  BOOST_TEST(10 == r2);

  BOOST_TEST(2 == calls);

  add = mul;

  int r3 = add(3, 5);
  BOOST_TEST(15 == r3);

  int r4 = mul(2, 5);
  BOOST_TEST(10 == r4);

  BOOST_TEST(4 == calls);
}

template<size_t Cap>
constexpr size_t expected_alignment_for_capacity()
{
    constexpr size_t alignof_ptr = std::alignment_of<void*>::value;
    constexpr size_t alignof_cap = std::alignment_of<std::aligned_storage_t<Cap>>::value;
#define MIN(a,b) (a < b ? a : b)
#define MAX(a,b) (a > b ? a : b)
    return MAX(MIN(Cap, alignof_cap), alignof_ptr);
#undef MAX
#undef MIN
}

namespace mjlib {
namespace base {
namespace test {
void test_struct_layout()
{
    static_assert(std::alignment_of< base::inplace_function<void(int), 1> >::value == expected_alignment_for_capacity<1>(), "");
    static_assert(std::alignment_of< base::inplace_function<void(int), 2> >::value == expected_alignment_for_capacity<2>(), "");
    static_assert(std::alignment_of< base::inplace_function<void(int), 4> >::value == expected_alignment_for_capacity<4>(), "");
    static_assert(std::alignment_of< base::inplace_function<void(int), 8> >::value == expected_alignment_for_capacity<8>(), "");
    static_assert(std::alignment_of< base::inplace_function<void(int), 16> >::value == expected_alignment_for_capacity<16>(), "");
    static_assert(std::alignment_of< base::inplace_function<void(int), 32> >::value == expected_alignment_for_capacity<32>(), "");
    static_assert(sizeof( base::inplace_function<void(int), sizeof(void*)> ) == 2 * sizeof(void*) + sizeof(size_t), "");
}
}
}
}

BOOST_AUTO_TEST_CASE(TestNullptr) {
  using IPF = base::inplace_function<void()>;
  auto nil = nullptr;
  const auto cnil = nullptr;

  IPF f;                    BOOST_TEST(! bool(f));
  f = nullptr;              BOOST_TEST(! bool(f));
  f = IPF(nullptr);         BOOST_TEST(! bool(f));
  f = IPF();                BOOST_TEST(! bool(f));
  f = IPF{};                BOOST_TEST(! bool(f));
  f = {};                   BOOST_TEST(! bool(f));
  f = nil;                  BOOST_TEST(! bool(f));
  f = IPF(nil);             BOOST_TEST(! bool(f));
  f = IPF(std::move(nil));  BOOST_TEST(! bool(f));
  f = cnil;                 BOOST_TEST(! bool(f));
  f = IPF(cnil);            BOOST_TEST(! bool(f));
  f = IPF(std::move(cnil)); BOOST_TEST(! bool(f));
}

namespace {
struct oon_functor {
  int dummy;

  oon_functor(int i) : dummy(i) {}
  int operator()(int i) { return i + dummy; }

  void *operator new (size_t, void *p) {
    BOOST_TEST(false);  // class-specific "new" should not be called
    return p;
  }
};
}

BOOST_AUTO_TEST_CASE(TestOverloadedOperatorNew) {
  using IPF = base::inplace_function<int(int), 8>;
  oon_functor oon(42);
  IPF fun = oon;
  IPF fun2;
  fun2 = oon;
  fun = fun2;
  BOOST_TEST(43 == fun(1));
}

BOOST_AUTO_TEST_CASE(TestMoveConstructionIsNoexcept) {
  using IPF = base::inplace_function<void(int), sizeof(Functor)>;
  std::vector<IPF> vec;
  vec.push_back(Functor());
  copied = 0;
  moved = 0;
  vec.reserve(vec.capacity() + 1);
  BOOST_TEST(0 == copied);
  BOOST_TEST(1 == moved);
}

BOOST_AUTO_TEST_CASE(TestMoveConstructionFromSmallerBufferIsNoexcept) {
  using IPF32 = base::inplace_function<void(int), 32>;
  using IPF40 = base::inplace_function<void(int), 40>;
  static_assert(std::is_nothrow_constructible<IPF32, IPF32&&>::value, "");
  static_assert(std::is_nothrow_assignable<IPF32, IPF32&&>::value, "");
  static_assert(std::is_nothrow_constructible<IPF40, IPF32&&>::value, "");
  static_assert(std::is_nothrow_assignable<IPF40, IPF32&&>::value, "");
}

BOOST_AUTO_TEST_CASE(RvalueRefParameter) {
  base::inplace_function<void(std::unique_ptr<int>&&)> f;
  f = [](std::unique_ptr<int>) {};
  f = [](std::unique_ptr<int>&&) {};
  f = [](const std::unique_ptr<int>&) {};
  f(std::make_unique<int>(42));
  base::inplace_function<void(std::unique_ptr<int>)> g;
  g = [](std::unique_ptr<int>) {};
  g = [](std::unique_ptr<int>&&) {};
  g = [](const std::unique_ptr<int>&) {};
  g(std::make_unique<int>(42));
}

BOOST_AUTO_TEST_CASE(TestIsConvertable) {
  static_assert(std::is_convertible<int(&)(), base::inplace_function<int()>>::value, "");
  static_assert(std::is_convertible<int(*)(), base::inplace_function<int()>>::value, "");
  static_assert(std::is_convertible<int(*&)(), base::inplace_function<int()>>::value, "");
  static_assert(std::is_convertible<int(*&&)(), base::inplace_function<int()>>::value, "");
}

BOOST_AUTO_TEST_CASE(TestConvertibilityWithQualifiedCallOperators) {
  struct Callable { void operator()() {} };
  struct LvalueOnlyCallable { void operator()() & {} };
  struct RvalueOnlyCallable { void operator()() && {} };
  struct ConstCallable { void operator()() const {} };
  struct ConstOnlyCallable { void operator()() const {} void operator()() = delete; };
  struct NonconstOnlyCallable { void operator()() {} void operator()() const = delete; };
  struct LvalueConstCallable { void operator()() const & {} };
  struct NoexceptCallable { void operator()() noexcept {} };
  static_assert(std::is_convertible<Callable, base::inplace_function<void()>>::value, "");
  static_assert(std::is_convertible<LvalueOnlyCallable, base::inplace_function<void()>>::value, "");
  static_assert(!std::is_convertible<RvalueOnlyCallable, base::inplace_function<void()>>::value, "");
  static_assert(std::is_convertible<ConstCallable, base::inplace_function<void()>>::value, "");
  static_assert(!std::is_convertible<ConstOnlyCallable, base::inplace_function<void()>>::value, "");
  static_assert(std::is_convertible<NonconstOnlyCallable, base::inplace_function<void()>>::value, "");
  static_assert(std::is_convertible<LvalueConstCallable, base::inplace_function<void()>>::value, "");
  static_assert(std::is_convertible<NoexceptCallable, base::inplace_function<void()>>::value, "");
}

BOOST_AUTO_TEST_CASE(TestConvertibilityWithLambdas) {
  struct NoDefaultCtor {
    int val;
    explicit NoDefaultCtor(int v) : val{v} {}
  };

  const auto a = []() -> int { return 3; };
  static_assert(std::is_convertible<decltype(a), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(a), base::inplace_function<int(int)>>::value, "");
  static_assert(!std::is_convertible<decltype(a), base::inplace_function<void(int&)>>::value, "");

  const auto b = [](int&) -> void {};
  static_assert(std::is_convertible<decltype(b), base::inplace_function<void(int&)>>::value, "");
  static_assert(!std::is_convertible<decltype(b), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(b), base::inplace_function<int(int)>>::value, "");

  const auto c = [](int, NoDefaultCtor) -> int { return 3; };
  static_assert(std::is_convertible<decltype(c), base::inplace_function<void(int, NoDefaultCtor)>>::value, "");
  static_assert(!std::is_convertible<decltype(c), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(c), base::inplace_function<int(int)>>::value, "");

  const auto d = []() -> void {};
  static_assert(std::is_convertible<decltype(d), base::inplace_function<void()>>::value, "");
  static_assert(!std::is_convertible<decltype(d), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(d), base::inplace_function<int(int)>>::value, "");

  static_assert(std::is_convertible<int(), base::inplace_function<const int&()>>::value, "");
  static_assert(std::is_convertible<int(*)(), base::inplace_function<const int&()>>::value, "");

  // Same as a, but not const.
  auto e = []() -> int { return 3; };
  static_assert(std::is_convertible<decltype(e), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(e), base::inplace_function<int(int)>>::value, "");
  static_assert(!std::is_convertible<decltype(e), base::inplace_function<void(int&)>>::value, "");

  // Same as a, but not const and mutable.
  auto f = []() mutable -> int { return 3; };
  static_assert(std::is_convertible<decltype(f), base::inplace_function<int()>>::value, "");
  static_assert(!std::is_convertible<decltype(f), base::inplace_function<int(int)>>::value, "");
  static_assert(!std::is_convertible<decltype(f), base::inplace_function<void(int&)>>::value, "");
}

namespace {
struct InstrumentedCopyConstructor {
  static int copies;
  static int moves;
  InstrumentedCopyConstructor() = default;
  InstrumentedCopyConstructor(const InstrumentedCopyConstructor&) {
    copies += 1;
  }
  InstrumentedCopyConstructor(InstrumentedCopyConstructor&&) noexcept {
    moves += 1;
  }
};
int InstrumentedCopyConstructor::copies = 0;
int InstrumentedCopyConstructor::moves = 0;
} // anonymous namespace

BOOST_AUTO_TEST_CASE(TestReturnByMove) {
  using IPF20 = base::inplace_function<void(), 20>;
  using IPF40 = base::inplace_function<void(), 40>;
  static_assert(std::is_convertible<IPF20, IPF40>::value, "");
  static_assert(std::is_convertible<IPF20&, IPF40>::value, "");
  static_assert(std::is_convertible<IPF20&&, IPF40>::value, "");
  static_assert(std::is_convertible<const IPF20&, IPF40>::value, "");
  static_assert(std::is_convertible<const IPF20&&, IPF40>::value, "");

  auto foo = []() -> IPF40 {
    InstrumentedCopyConstructor cc;
    InstrumentedCopyConstructor::copies = 0;
    InstrumentedCopyConstructor::moves = 0;
    IPF20 f = [cc]() { };
    BOOST_TEST(InstrumentedCopyConstructor::copies == 1);
    BOOST_TEST(InstrumentedCopyConstructor::moves == 1);
    InstrumentedCopyConstructor::copies = 0;
    InstrumentedCopyConstructor::moves = 0;
    return f;
  };
  IPF40 f = foo();
  BOOST_TEST(InstrumentedCopyConstructor::copies == 0);
  BOOST_TEST(InstrumentedCopyConstructor::moves == 1);
}

BOOST_AUTO_TEST_CASE(TestIsInvocable) {
  using C_Int1 = int();
  using C_Int2 = int(int);
  using C_Void = void(int&);

  using base::inplace_function_detail::is_invocable_r;

  static_assert(is_invocable_r<int, C_Int1>::value, "");
  static_assert(! is_invocable_r<int, C_Int2>::value, "");
  static_assert(! is_invocable_r<int, C_Void>::value, "");

  static_assert(is_invocable_r<int, C_Int2, int>::value, "");
  static_assert(! is_invocable_r<int, C_Int1, int>::value, "");
  static_assert(! is_invocable_r<int, C_Void, int>::value, "");

  static_assert(is_invocable_r<void, C_Void, int&>::value, "");
  static_assert(! is_invocable_r<void, C_Int1, int&>::value, "");

  // Testing widening and narrowing conversions, and the "conversion" to void.
  static_assert(is_invocable_r<void, C_Int1>::value, "");
  static_assert(is_invocable_r<long, C_Int1>::value, "");
  static_assert(is_invocable_r<char, C_Int1>::value, "");

  // Testing the conversion from void to int, which should definitely not be allowed.
  static_assert(! is_invocable_r<int, C_Void, int&>::value, "");

  // cppreference:
  // > Determines whether Fn can be invoked with the arguments ArgTypes...
  // > to yield a result that is convertible to R.
  //
  // void is treated specially because a functions return value can be ignored.
  static_assert(is_invocable_r<void, C_Int2, int&>::value, "");
  static_assert(is_invocable_r<const void, C_Int2, int&>::value, "");

  // Regression tests for both is_invocable and is_convertible.
  static_assert(is_invocable_r<const int&, int()>::value, "");
  static_assert(is_invocable_r<const int&, int(*)()>::value, "");
}

static int overloaded_function(base::inplace_function<int()>) { return 1; }
static int overloaded_function(base::inplace_function<int(int)>) { return 2; }

BOOST_AUTO_TEST_CASE(TestOverloadingOnArity) {
    BOOST_TEST(overloaded_function([]() { return 0; }) == 1);
    BOOST_TEST(overloaded_function([](int) { return 0; }) == 2);
}


static int overloaded_function2(base::inplace_function<int(int)>) { return 1; }
static int overloaded_function2(base::inplace_function<int(int*)>) { return 2; }

BOOST_AUTO_TEST_CASE(TestOverloadingOnParameterType) {
  BOOST_TEST(overloaded_function2([](int) { return 0; }) == 1);
  BOOST_TEST(overloaded_function2([](int*) { return 0; }) == 2);
}

static int overloaded_function3(base::inplace_function<int(int)>) { return 1; }
static int overloaded_function3(base::inplace_function<int*(int)>) { return 2; }

BOOST_AUTO_TEST_CASE(TestOverloadingOnReturnType) {
  BOOST_TEST(overloaded_function3([](int) { return 0; }) == 1);
  BOOST_TEST(overloaded_function3([](int) { return nullptr; }) == 2);
}

namespace {
void Foo(int i)
{
  assert(i == expected);
  called_with = i;
}
}

BOOST_AUTO_TEST_CASE(InplaceFunctionTest) {
  // second set of tests
  using IPF = base::inplace_function<void(int)>;
  static_assert(std::is_nothrow_default_constructible<IPF>::value, "");
  static_assert(std::is_copy_constructible<IPF>::value, "");
  static_assert(std::is_move_constructible<IPF>::value, "");
  static_assert(std::is_copy_assignable<IPF>::value, "");
  static_assert(std::is_move_assignable<IPF>::value, "");
#if __cplusplus >= 201703L
  static_assert(std::is_swappable<IPF&>::value, "");
  static_assert(std::is_invocable<const IPF&, int>::value, "");
  static_assert(std::is_invocable_r<void, const IPF&, int>::value, "");
#endif
  static_assert(std::is_nothrow_destructible<IPF>::value, "");

  IPF func;
  BOOST_TEST(!func);
  BOOST_TEST(!bool(func));
  BOOST_TEST((func == nullptr));
  BOOST_TEST(!(func != nullptr));

  func = Foo;
  BOOST_TEST(!!func);
  BOOST_TEST(bool(func));
  BOOST_TEST(!(func == nullptr));
  BOOST_TEST((func != nullptr));
  called_with = 0; expected = 42; func(42); BOOST_TEST(called_with == 42);

  func = nullptr;
  BOOST_TEST(!func);
  BOOST_TEST(!bool(func));
  BOOST_TEST((func == nullptr));
  BOOST_TEST(!(func != nullptr));

  using IPF40 = base::inplace_function<void(int), 40>; // the default is 32
  static_assert(std::is_constructible<IPF40, const IPF&>::value, "");
  static_assert(std::is_constructible<IPF40, IPF&&>::value, "");  // TODO: nothrow
  static_assert(std::is_assignable<IPF40&, const IPF&>::value, "");
  static_assert(std::is_assignable<IPF40&, IPF&&>::value, "");  // TODO: nothrow
  //static_assert(!std::is_assignable<IPF&, const IPF40&>::value, "");
  //static_assert(!std::is_assignable<IPF&, IPF40&&>::value, "");
#if __cplusplus >= 201703L && !defined(_WIN32)
  static_assert(!std::is_swappable_with<IPF40&, IPF&>::value, "");
  static_assert(!std::is_swappable_with<IPF&, IPF40&>::value, "");
#endif
  static_assert(std::is_nothrow_destructible<IPF40>::value, "");

  IPF40 func40;
  BOOST_TEST(!func40);
  BOOST_TEST(!bool(func40));
  BOOST_TEST((func40 == nullptr));
  BOOST_TEST(!(func40 != nullptr));

  func = nullptr;
  func40 = func;
  BOOST_TEST(!func40);
  BOOST_TEST(!bool(func40));
  BOOST_TEST((func40 == nullptr));
  BOOST_TEST(!(func40 != nullptr));
}

BOOST_AUTO_TEST_CASE(InplaceShrink) {
  base::inplace_function<int(int), 40> start = [](int v) { return v + 1; };
  BOOST_TEST(start(10) == 11);

  auto smaller = start.shrink<32>();
  BOOST_TEST(smaller(12) == 13);

  static_assert(sizeof(smaller) < sizeof(start), "");
}

BOOST_AUTO_TEST_CASE(EmptyDelete) {
  {
    base::inplace_function<int()> dut;
  }
  BOOST_TEST(true);
}
